---
title: Création d’un jeton Web JSON (JWT)
description: Créez un jeton Web JSON (JWT) qui peut être échangé avec les API Adobe IMS pour un jeton d’accès AEM.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
kt: 9980
exl-id: 0e3e186b-9fbe-40ad-a6cc-bdbf58b23009
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '114'
ht-degree: 0%

---

# Création d’un jeton Web JSON (JWT)

Les jetons web JSON sont une méthode ouverte, standard RFC 7519, permettant de représenter en toute sécurité les revendications entre deux parties. Les bibliothèques JWT.io ont été utilisées dans cet exemple pour générer le JWT.
Les informations d’identification de service que vous avez téléchargées à l’étape précédente contiennent la clé privée au format PKCS#1. Pour extraire la clé privée de cette chaîne, nous avons utilisé [BouncyCastle](https://www.bouncycastle.org/) bibliothèques. Les bibliothèques de cryptage qui font partie de java ne prennent pas en charge le format PKCS#1.

Le code suivant a été utilisé pour générer le JWT :

```java
public String getJWTToken()
    {
            Security.addProvider(new BouncyCastleProvider());
            RSAPrivateKey privateKey = null;
            GetServiceCredentials getCredentials = new GetServiceCredentials();
            try 
            {

                long now = System.currentTimeMillis();
                Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
                String privateKeyString = getCredentials.getPRIVATE_KEY();
                //The JWT signature algorithm we use to sign the token
                SignatureAlgorithm sa = SignatureAlgorithm.RS256;
                
                
                Reader targetReader = new StringReader(privateKeyString);
                // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
                PEMParser pemParser = new PEMParser(targetReader);
                // tores the result generated by the pEMParser
                Object object = pemParser.readObject();
                JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
                KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
                privateKey = (RSAPrivateKey) kp.getPrivate();
                
              //Let's set the JWT Claims

                Map < String, Object > jwtClaims = new HashMap < String, Object > ();
                jwtClaims.put("iss", getCredentials.getORG_ID());
                jwtClaims.put("sub", getCredentials.getTECH_ACCT());
                jwtClaims.put("exp", expirationTime);
                jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
                String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
                    
                for (String metascope: metascopes)
                {
                            jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
                }

                
                // Create the final JWT token
                String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
                    System.out.println("Got JWT Token " + jwtToken);
                    pemParser.close();
                return jwtToken;

            } catch (IOException e) {
                
                    System.out.println("The error is " + e.getMessage());
            }
            return null;

    }
```
