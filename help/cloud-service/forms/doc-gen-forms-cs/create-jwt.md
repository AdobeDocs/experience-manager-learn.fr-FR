---
title: Créer un jeton web JSON
description: Créez un jeton web JSON (JWT) qui peut être échangé avec les API Adobe IMS contre un jeton d’accès AEM.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
jira: KT-8184
thumbnail: 8184.jpg
exl-id: 394ed621-1106-4b2a-a6b7-2efa5867f5b1
duration: 45
source-git-commit: f23c2ab86d42531113690df2e342c65060b5c7cd
workflow-type: tm+mt
source-wordcount: '112'
ht-degree: 100%

---

# Créer un jeton web JSON

Les jetons web JSON constituent une méthode ouverte, conforme à la norme RFC 7519, permettant de représenter en toute sécurité les demandes entre deux parties. Les bibliothèques JWT.io ont été utilisées dans cet exemple pour générer le JWT.
Les informations d’identification de service que vous avez téléchargées à l’étape précédente contiennent la clé privée au format PKCS#1. Pour extraire la clé privée de cette chaîne, nous avons utilisé les bilbiothèques [BouncyCastle](https://www.bouncycastle.org/). Les bibliothèques de cryptage qui font partie de Java ne prennent pas en charge le format PKCS#1.

Le code suivant a été utilisé pour générer le JWT :

```java
public String getJWTToken()
    {
            Security.addProvider(new BouncyCastleProvider());
            RSAPrivateKey privateKey = null;
            GetServiceCredentials getCredentials = new GetServiceCredentials();
            try 
            {

                long now = System.currentTimeMillis();
                Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
                String privateKeyString = getCredentials.getPRIVATE_KEY();
              //The JWT signature algorithm we use to sign the token
                SignatureAlgorithm sa = SignatureAlgorithm.RS256;
                
                
                Reader targetReader = new StringReader(privateKeyString);
                // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
                PEMParser pemParser = new PEMParser(targetReader);
                // tores the result generated by the pEMParser
                Object object = pemParser.readObject();
                JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
                KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
                privateKey = (RSAPrivateKey) kp.getPrivate();
                
              //Let's set the JWT Claims

                Map < String, Object > jwtClaims = new HashMap < String, Object > ();
                jwtClaims.put("iss", getCredentials.getORG_ID());
                jwtClaims.put("sub", getCredentials.getTECH_ACCT());
                jwtClaims.put("exp", expirationTime);
                jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
                String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
                    
                for (String metascope: metascopes)
                {
                            jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
                }

                
                // Create the final JWT token
                String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
                    System.out.println("Got JWT Token " + jwtToken);
                    pemParser.close();
                return jwtToken;

            } catch (IOException e) {
                
                    System.out.println("The error is " + e.getMessage());
            }
            return null;

    }
```
