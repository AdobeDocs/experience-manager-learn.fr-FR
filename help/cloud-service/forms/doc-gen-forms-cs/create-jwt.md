---
title: Création d’un jeton Web JSON (JWT)
description: Créez un jeton Web JSON (JWT) qui peut être échangé avec les API IMS d’Adobe pour un jeton d’accès AEM.
type: Documentation
role: Developer
level: Beginner, Intermediate
version: Cloud Service
feature: Adaptive Forms
topic: Development
kt: 8184
thumbnail: 8184.jpg
source-git-commit: ad203d7a34f5eff7de4768131c9b4ebae261da93
workflow-type: tm+mt
source-wordcount: '114'
ht-degree: 0%

---

# Création d’un jeton Web JSON (JWT)


Les jetons web JSON sont une méthode ouverte, standard RFC 7519, permettant de représenter en toute sécurité les revendications entre deux parties. Les bibliothèques JWT.io ont été utilisées dans cet exemple pour générer le JWT.
Les informations d’identification de service que vous avez téléchargées à l’étape précédente contiennent la clé privée au format PKCS#1. Pour extraire la clé privée de cette chaîne, nous avons utilisé les bibliothèques [BouncyCastle](https://www.bouncycastle.org/). Les bibliothèques de cryptage qui font partie de java ne prennent pas en charge le format PKCS#1.

Le code suivant a été utilisé pour générer le JWT :

```java
public String getJWTToken()
	{
	        Security.addProvider(new BouncyCastleProvider());
	        RSAPrivateKey privateKey = null;
	        GetServiceCredentials getCredentials = new GetServiceCredentials();
	        try 
	        {

	            long now = System.currentTimeMillis();
	            Long expirationTime = now + TimeUnit.MINUTES.toMillis(5);
                // get the private key string from the service credentials
	            String privateKeyString = getCredentials.getPRIVATE_KEY();
	          //The JWT signature algorithm we will be using to sign the token
	            SignatureAlgorithm sa = SignatureAlgorithm.RS256;
	            
	            
	            Reader targetReader = new StringReader(privateKeyString);
	            // PEMParser removes the unnecessary headers and decodes the underlying Base64 PEM data into a binary format.
	            PEMParser pemParser = new PEMParser(targetReader);
	            // tores the result generated by the pEMParser
	            Object object = pemParser.readObject();
	            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
	            KeyPair kp = converter.getKeyPair((PEMKeyPair) object);
	            privateKey = (RSAPrivateKey) kp.getPrivate();
	            
	          //Let's set the JWT Claims

	            Map < String, Object > jwtClaims = new HashMap < String, Object > ();
	            jwtClaims.put("iss", getCredentials.getORG_ID());
	            jwtClaims.put("sub", getCredentials.getTECH_ACCT());
	            jwtClaims.put("exp", expirationTime);
	            jwtClaims.put("aud", "https://" + getCredentials.getIMS_ENDPOINT() + "/c/" + getCredentials.getCLIENT_ID());
	            String metascopes[] = new String[] { getCredentials.getMETASCOPE_ID() };
	                
	            for (String metascope: metascopes)
	            {
	                        jwtClaims.put("https://" + getCredentials.getIMS_ENDPOINT() + "/s/" + metascope, java.lang.Boolean.TRUE);
	            }

	            
	            // Create the final JWT token
	            String jwtToken = Jwts.builder().setClaims(jwtClaims).signWith(sa, privateKey).compact();
	                System.out.println("Got JWT Token " + jwtToken);
	                pemParser.close();
	            return jwtToken;

	        } catch (IOException e) {
	            
	                System.out.println("The error is " + e.getMessage());
	        }
	        return null;

	}
```
